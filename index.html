# backend/main.py
import os, hashlib, io, time
from typing import List
from contextlib import asynccontextmanager
from fastapi import FastAPI, File, UploadFile, HTTPException, Request, Form
from fastapi.middleware.cors import CORSMiddleware
from PIL import Image
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sentence_transformers import SentenceTransformer

# ‚¨áÔ∏è IMPORTS PARA SISTEMA DE USUARIOS Y FEEDBACK:
from dotenv import load_dotenv
from datetime import datetime, timedelta
import json
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Text, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session, relationship
from fastapi import Depends
from pydantic import BaseModel

# ‚¨áÔ∏è CARGAR VARIABLES DEL .env:
load_dotenv()

# ---------- Config ----------
_model = None

def get_model():
    """Cargar modelo solo cuando sea necesario"""
    global _model
    if _model is None:
        print("Cargando modelo...")
        _model = SentenceTransformer("clip-ViT-B-32")  # Modelo m√°s liviano
        print("Modelo cargado exitosamente")
    return _model

ALLOWED = {"image/jpeg", "image/png", "image/jpg", "image/webp", "image/gif",
           "image/svg+xml", "image/tiff", "image/bmp", "image/x-icon", "image/heic", "image/heif"}

# Aumentar l√≠mite a 20MB
MAX_MB = 20

# CORS configurable por ENV (coma-separado) o default a tu dominio
_env_origins = os.getenv(
    "ALLOWED_ORIGINS",
    "https://www.ailovereuse.com,https://ailovereuse.com,http://localhost:3000,http://localhost:5173,http://localhost:8080"
)
ALLOWED_ORIGINS = [o.strip() for o in _env_origins.split(",") if o.strip()]

# ---------- Database Config ----------
DATABASE_URL = "sqlite:///./ailovereuse.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ---------- Database Models ----------
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    name = Column(String, nullable=True)  # Nombre de Google
    google_id = Column(String, nullable=True)  # ID de Google
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Integer, default=1)

    # Relaciones
    history = relationship("UserHistory", back_populates="user")
    feedback = relationship("UserFeedback", back_populates="user")  # Nueva relaci√≥n

class UserHistory(Base):
    __tablename__ = "user_history"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    plan_type = Column(String, default="B√°sico")
    start_date = Column(DateTime, default=datetime.utcnow)
    recommendations_count = Column(Integer, default=0)
    outfits_created = Column(Text, default="[]")  # JSON string

    # Relaci√≥n con usuario
    user = relationship("User", back_populates="history")

class UserFeedback(Base):
    """Tabla para almacenar feedback de combinaciones"""
    __tablename__ = "user_feedback"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    combination_id = Column(String, nullable=False)  # A1, B1, C1, etc.
    accepted = Column(String, nullable=False)  # 'si' o 'no'
    rejection_reason = Column(String, nullable=True)  # Solo si accepted = 'no'
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relaci√≥n con usuario
    user = relationship("User", back_populates="feedback")

# Crear tablas
Base.metadata.create_all(bind=engine)

# ---------- Database Dependencies ----------
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------- User Helper Functions ----------
def get_or_create_user_by_email(db: Session, email: str, name: str = None) -> User:
    """Obtener usuario existente o crear uno nuevo por email"""
    user = db.query(User).filter(User.email == email).first()

    if not user:
        # Auto-crear usuario nuevo
        user = User(
            email=email,
            name=name,
            created_at=datetime.utcnow()
        )
        db.add(user)
        db.commit()
        db.refresh(user)

        # Crear historial inicial
        history = UserHistory(user_id=user.id)
        db.add(history)
        db.commit()

        print(f"‚úÖ Usuario auto-creado: {email}")

    return user

def update_user_stats(db: Session, user_id: int, action_type: str):
    """Actualizar estad√≠sticas del usuario"""
    history = db.query(UserHistory).filter(UserHistory.user_id == user_id).first()
    if not history:
        # Crear historial si no existe
        history = UserHistory(user_id=user_id)
        db.add(history)

    if action_type == 'recommendation':
        history.recommendations_count += 1
    elif action_type == 'outfit_created':
        outfits = json.loads(history.outfits_created)
        outfits.append({
            'date': datetime.utcnow().isoformat(),
            'type': 'outfit_generated'
        })
        history.outfits_created = json.dumps(outfits)

    db.commit()

# ---------- Cache y Lifespan ----------
_cache: dict[str, np.ndarray] = {}

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("üöÄ Iniciando ailovereuse...")
    print("ü§ñ Pre-calentando IA...")

    # Cargar modelo al startup
    model = get_model()

    # Hacer inferencia dummy para cargar todo en memoria
    model.encode("warmup text")

    print("‚úÖ IA lista - ailovereuse preparado para usuarios!")
    print("üîê Autenticaci√≥n: Google Login integrado")
    print("üìä Base de datos: ailovereuse.db")
    print("üí¨ Sistema de feedback: Activado")
    print("API iniciada")

    yield

    print("API cerrada")

# ---------- App ----------
if os.getenv("ENVIRONMENT") == "development":
    ALLOWED_ORIGINS = ["*"]

print("üåê CORS Origins permitidos:", ALLOWED_ORIGINS)

app = FastAPI(title="I Love Reuse AI - Outfit Recommender", lifespan=lifespan)
app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
)

# ---------- Utilidades ----------
def _hash(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

def _load_img(b: bytes) -> Image.Image:
    img = Image.open(io.BytesIO(b)).convert("RGB")
    try:
        # Aplicar orientaci√≥n EXIF si la tiene
        from PIL import ImageOps
        img = ImageOps.exif_transpose(img)
    except Exception:
        pass
    return img

def _embed(img: Image.Image) -> np.ndarray:
    model = get_model()  # ‚Üê Cargar solo cuando se necesite
    e = model.encode([img], convert_to_numpy=True, normalize_embeddings=True)[0]
    return e

def classify_formality(img: Image.Image) -> str:
    labels = ["formal outfit", "informal outfit", "dress shoe", "sneaker"]
    model = get_model()  # ‚Üê Cargar solo cuando se necesite
    txt = model.encode(labels, convert_to_numpy=True, normalize_embeddings=True)
    v = _embed(img).reshape(1, -1)
    s = cosine_similarity(v, txt)[0]
    return "formal" if (s[0] + s[2]) >= (s[1] + s[3]) else "informal"

def combine(a: np.ndarray, b: np.ndarray) -> np.ndarray:
    v = (a + b) / 2.0
    return v / (np.linalg.norm(v) + 1e-9)

def resize_uploaded_image(image_bytes, size=(128, 128)):
    img = Image.open(io.BytesIO(image_bytes))
    img = img.resize(size, Image.Resampling.LANCZOS)
    buffer = io.BytesIO()
    img.save(buffer, format='PNG', optimize=True)
    buffer.seek(0)
    return buffer.getvalue()

# ---------- Zero-shot prompts para "¬øes prenda?" ----------
CLOTHING_LABELS_EN = [
    "a photo of a piece of clothing", "a photo of clothing", "a photo of an outfit",
    "a photo of a shirt", "a photo of a blouse", "a photo of a t-shirt",
    "a photo of a sweater", "a photo of a hoodie", "a photo of pants", "a photo of jeans",
    "a photo of a skirt", "a photo of shorts", "a photo of a dress",
    "a photo of a jacket", "a photo of a coat", "a photo of a blazer", "a photo of a parka",
    "a photo of a pair of shoes", "a photo of sneakers", "a photo of boots",
    "a photo of heels", "a photo of loafers", "a photo of sandals",
    "a photo of a handbag", "a photo of a purse", "a photo of a backpack",
    "a photo of a belt", "a photo of a scarf", "a photo of sunglasses",
    "a photo of jewelry", "a photo of a wallet", "a photo of socks"
]

NON_CLOTHING_LABELS_EN = [
    "a photo of an animal", "a photo of a dog", "a photo of a cat",
    "a photo of a house", "a photo of a room", "a photo of a window",
    "a photo of a car", "a photo of a wheel", "a photo of a motorcycle",
    "a photo of furniture", "a photo of a chair", "a photo of a table",
    "a photo of food", "a photo of electronics", "a photo of a phone",
    "a photo of a landscape", "a photo of a city", "a photo of a person portrait"
]

_text_cache = {"clothing": None, "non_clothing": None}

def _get_text_embs():
    model = get_model()
    if _text_cache["clothing"] is None:
        _text_cache["clothing"] = model.encode(
            CLOTHING_LABELS_EN, convert_to_numpy=True, normalize_embeddings=True
        )
    if _text_cache["non_clothing"] is None:
        _text_cache["non_clothing"] = model.encode(
            NON_CLOTHING_LABELS_EN, convert_to_numpy=True, normalize_embeddings=True
        )
    return _text_cache["clothing"], _text_cache["non_clothing"]

def is_clothing_image(img: Image.Image, thr: float = 0.30, margin: float = 0.10):
    """
    Zero-shot con CLIP para decidir si una imagen es de prenda/accesorio/outfit.
    thr: similitud m√≠nima con 'ropa' para aceptar.
    margin: 'ropa' debe superar a 'no-ropa' al menos por este margen.
    """
    model = get_model()
    clothing_embs, non_clothing_embs = _get_text_embs()

    img_emb = model.encode(img, convert_to_numpy=True, normalize_embeddings=True).reshape(1, -1)

    sim_clothing = cosine_similarity(img_emb, clothing_embs)[0]
    sim_non_clothing = cosine_similarity(img_emb, non_clothing_embs)[0]

    best_clothing = float(np.max(sim_clothing))
    best_non_clothing = float(np.max(sim_non_clothing))
    best_label = CLOTHING_LABELS_EN[int(np.argmax(sim_clothing))]

    ok = (best_clothing >= thr) and (best_clothing > best_non_clothing + margin)

    return ok, {
        "best_clothing_score": round(best_clothing, 3),
        "best_non_clothing_score": round(best_non_clothing, 3),
        "predicted_label": best_label if ok else "NOT_CLOTHING"
    }

# (Opcional) filtro espec√≠fico para calzado
FOOTWEAR_LABELS_EN = [
    "a photo of a pair of shoes", "a photo of sneakers", "a photo of boots",
    "a photo of heels", "a photo of loafers", "a photo of sandals"
]
def is_footwear_image(img: Image.Image, thr: float = 0.30):
    model = get_model()
    footwear_embs = model.encode(FOOTWEAR_LABELS_EN, convert_to_numpy=True, normalize_embeddings=True)
    img_emb = model.encode(img, convert_to_numpy=True, normalize_embeddings=True).reshape(1, -1)
    sim = cosine_similarity(img_emb, footwear_embs)[0]
    return (float(np.max(sim)) >= thr)

# ---------- Main Endpoints ----------
@app.get("/")
def read_root():
    return {
        "message": "I Love Reuse AI - Outfit Recommender funcionando!",
        "version": "4.0",
        "auth": "Google Login integrado",
        "model": "lazy-loaded",
        "max_file_size": f"{MAX_MB}MB",
        "database": "SQLite - ailovereuse.db",
        "feedback_system": "Activo"
    }

@app.get("/health")
def health():
    return {
        "ok": True,
        "ts": int(time.time()),
        "model_loaded": _model is not None,
        "max_file_size": f"{MAX_MB}MB",
        "auth_system": "google_integrated",
        "database": "ailovereuse.db",
        "features": ["recommendations", "user_tracking", "feedback_system"]
    }

# ---------- User History Endpoint ----------
@app.get("/user/history/{email}")
async def get_user_history_by_email(email: str, db: Session = Depends(get_db)):
    """Obtener historial de usuario por email (para usuarios loggeados con Google)"""
    user = db.query(User).filter(User.email == email).first()

    if not user:
        # Si no existe, crear usuario autom√°ticamente
        user = get_or_create_user_by_email(db, email)

    history = db.query(UserHistory).filter(UserHistory.user_id == user.id).first()

    if not history:
        # Crear historial si no existe
        history = UserHistory(user_id=user.id)
        db.add(history)
        db.commit()
        db.refresh(history)

    # Calcular d√≠as restantes
    days_passed = (datetime.utcnow() - history.start_date).days
    days_remaining = max(0, 30 - days_passed)

    # Obtener estad√≠sticas de feedback
    total_feedback = db.query(UserFeedback).filter(UserFeedback.user_id == user.id).count()
    accepted_feedback = db.query(UserFeedback).filter(
        UserFeedback.user_id == user.id,
        UserFeedback.accepted == 'si'
    ).count()

    return {
        "success": True,
        "user": {
            "email": user.email,
            "name": user.name,
            "joined": user.created_at.strftime('%d/%m/%Y')
        },
        "data": {
            "start_date": history.start_date.strftime('%d/%m/%Y'),
            "plan_type": history.plan_type,
            "days_remaining": days_remaining,
            "recommendations_count": history.recommendations_count,
            "outfits_created": json.loads(history.outfits_created),
            "feedback_given": total_feedback,
            "acceptance_rate": round(accepted_feedback / max(total_feedback, 1) * 100, 1)
        }
    }

# ---------- Classification Endpoint ----------
@app.post("/classify")
async def classify(file: UploadFile = File(...)):
    # Verificar tipo de archivo (case-insensitive)
    if file.content_type.lower() not in ALLOWED:
        raise HTTPException(415, f"Tipo de archivo no permitido: {file.content_type}. Por favor sube una imagen v√°lida (JPG, PNG, etc.)")

    b = await file.read()
    file_size_mb = len(b) / (1024 * 1024)  # Convertir a MB

    if len(b) > MAX_MB * 1024 * 1024:
        raise HTTPException(413, f"La imagen es muy grande ({file_size_mb:.1f}MB). Por favor sube una foto m√°s peque√±a (m√°ximo {MAX_MB}MB)")

    try:
        img = _load_img(b)
    except Exception:
        raise HTTPException(400, "Archivo de imagen inv√°lido. Por favor verifica que sea una imagen v√°lida")

    # ‚úÖ Validaci√≥n de prenda/outfit antes de clasificar
    ok, info = is_clothing_image(img)
    if not ok:
        raise HTTPException(
            status_code=422,
            detail={
                "code": "NOT_CLOTHING",
                "message": "La imagen no corresponde a una prenda ni outfit.",
                "debug": info  # quita 'debug' en producci√≥n si no quieres exponer detalles
            }
        )

    return {"formality": classify_formality(img)}

# ---------- Recommendation Endpoint (CON GOOGLE AUTH INTEGRADO) ----------
@app.post("/recommend")
async def recommend(
    request: Request,
    top: UploadFile = File(...),
    bottom: UploadFile = File(...),
    shoes: List[UploadFile] = File(...),
    user_email: str = Form(...),  # üëà Email del usuario loggeado con Google
    user_name: str = Form(None),  # üëà Nombre opcional de Google
    db: Session = Depends(get_db)
):
    """
    Generar recomendaci√≥n de outfit.

    Par√°metros:
    - top: Imagen de parte superior
    - bottom: Imagen de parte inferior
    - shoes: Lista de im√°genes de zapatos
    - user_email: Email del usuario (obtenido del login de Google)
    - user_name: Nombre del usuario (opcional, de Google)
    """

    # Validar email
    if not user_email or "@" not in user_email:
        raise HTTPException(400, "Email de usuario requerido y v√°lido")

    # Obtener o crear usuario autom√°ticamente
    user = get_or_create_user_by_email(db, user_email, user_name)

    # Validar y leer archivos
    files_all = [("top", top), ("bottom", bottom)] + [(f"shoe[{i}]", s) for i, s in enumerate(shoes)]
    buffers: dict[str, bytes] = {}

    for name, f in files_all:
        # Verificar tipo de archivo (case-insensitive)
        if f.content_type.lower() not in ALLOWED:
            raise HTTPException(415, f"Tipo de archivo no permitido en {name}: {f.content_type}. Por favor sube una imagen v√°lida (JPG, PNG, etc.)")

        b = await f.read()
        if not b:
            raise HTTPException(400, f"El archivo {name} est√° vac√≠o. Por favor selecciona una imagen v√°lida")

        file_size_mb = len(b) / (1024 * 1024)  # Convertir a MB
        if len(b) > MAX_MB * 1024 * 1024:
            raise HTTPException(413, f"La imagen {name} es muy grande ({file_size_mb:.1f}MB). Por favor sube una foto m√°s peque√±a (m√°ximo {MAX_MB}MB)")

        # ‚úÖ Validaci√≥n sem√°ntica: debe ser prenda/outfit/accesorio
        try:
            _img_tmp = _load_img(b)
        except Exception:
            raise HTTPException(400, f"El archivo {name} no es una imagen v√°lida")

        ok, info = is_clothing_image(_img_tmp)
        if not ok:
            raise HTTPException(
                status_code=422,
                detail={
                    "code": "NOT_CLOTHING",
                    "field": name,  # ej: "top", "bottom", "shoe[0]"
                    "message": "La imagen no corresponde a una prenda, calzado, accesorio ni outfit.",
                    "debug": info
                }
            )

        # (Opcional) si quieres que 'shoes' solo acepte calzado:
        if name.startswith("shoe["):
            if not is_footwear_image(_img_tmp):
                raise HTTPException(
                    status_code=422,
                    detail={
                        "code": "NOT_FOOTWEAR",
                        "field": name,
                        "message": "La imagen en la secci√≥n de calzado no parece ser un zapato/zapatilla.",
                    }
                )

        buffers[name] = b

    def get_emb(b: bytes) -> np.ndarray:
        key = _hash(b)
        if key not in _cache:
            _cache[key] = _embed(_load_img(b))
        return _cache[key]

    e_top = get_emb(buffers["top"])
    e_bot = get_emb(buffers["bottom"])
    outfit = combine(e_top, e_bot).reshape(1, -1)

    shoe_keys = [k for k in buffers.keys() if k.startswith("shoe[")]
    if not shoe_keys:
        raise HTTPException(400, "Debes enviar al menos una imagen de zapatos")

    shoe_embs = [get_emb(buffers[k]).reshape(1, -1) for k in shoe_keys]
    sims = [float(cosine_similarity(outfit, e)[0][0]) for e in shoe_embs]
    order = np.argsort(-np.array(sims)).tolist()
    k = min(3, len(order))

    results = []
    for rank, i in enumerate(order[:k], start=1):
        key = shoe_keys[i]
        label = classify_formality(_load_img(buffers[key]))
        results.append({
            "index": i,
            "score": sims[i],
            "formality": label,
            "combination": rank
        })

    # üéØ ACTUALIZAR ESTAD√çSTICAS DEL USUARIO
    update_user_stats(db, user.id, 'recommendation')

    # Obtener contador actualizado
    history = db.query(UserHistory).filter(UserHistory.user_id == user.id).first()
    total_recommendations = history.recommendations_count if history else 1

    payload = {
        "best_index": results[0]["index"] if results else None,
        "results": results,
        "user": {
            "email": user.email,
            "recommendations_total": total_recommendations
        }
    }

    print(f"‚úÖ Recomendaci√≥n generada para {user.email} (Total: {total_recommendations})")
    return payload

# ---------- üéØ Feedback Endpoint ----------
@app.post("/api/feedback")
async def store_user_feedback(
    user_email: str = Form(...),
    combination_id: str = Form(...),
    accepted: str = Form(...),  # 'si' o 'no'
    rejection_reason: str = Form(None),  # opcional
    db: Session = Depends(get_db)
):
    """Almacenar feedback del usuario sobre combinaciones"""

    # Validar email
    if not user_email or "@" not in user_email:
        raise HTTPException(400, "Email v√°lido requerido")

    # Validar accepted
    if accepted not in ['si', 'no']:
        raise HTTPException(400, "accepted debe ser 'si' o 'no'")

    # Obtener usuario
    user = db.query(User).filter(User.email == user_email).first()
    if not user:
        raise HTTPException(404, "Usuario no encontrado")

    try:
        # Crear registro de feedback
        feedback = UserFeedback(
            user_id=user.id,
            combination_id=combination_id,
            accepted=accepted,
            rejection_reason=rejection_reason if accepted == 'no' else None
        )

        db.add(feedback)
        db.commit()
        db.refresh(feedback)

        print(f"‚úÖ Feedback almacenado: {user.email} - {combination_id} - {accepted}")
        if rejection_reason:
            print(f"   Raz√≥n de rechazo: {rejection_reason}")

        return {
            "success": True,
            "message": "Feedback almacenado correctamente",
            "feedback_id": feedback.id
        }

    except Exception as e:
        db.rollback()
        raise HTTPException(500, f"Error almacenando feedback: {str(e)}")

# ---------- Admin Endpoints ----------
@app.get("/admin/stats")
async def get_admin_stats(db: Session = Depends(get_db)):
    """
    Estad√≠sticas generales de la aplicaci√≥n para el administrador
    """
    try:
        # Contar usuarios totales
        total_users = db.query(User).count()

        # Usuarios de hoy
        today = datetime.utcnow().date()
        today_users = db.query(User).filter(
            User.created_at >= datetime.combine(today, datetime.min.time())
        ).count()

        # Usuarios de esta semana
        week_ago = datetime.utcnow() - timedelta(days=7)
        week_users = db.query(User).filter(User.created_at >= week_ago).count()

        # Usuarios activos (con recomendaciones)
        active_users = db.query(UserHistory).filter(
            UserHistory.recommendations_count > 0
        ).count()

        # Total de recomendaciones generadas
        total_recommendations = db.query(UserHistory).with_entities(
            db.func.sum(UserHistory.recommendations_count)
        ).scalar() or 0

        # üéØ NUEVAS ESTAD√çSTICAS DE FEEDBACK
        total_feedback = db.query(UserFeedback).count()
        accepted_feedback = db.query(UserFeedback).filter(UserFeedback.accepted == 'si').count()
        rejected_feedback = db.query(UserFeedback).filter(UserFeedback.accepted == 'no').count()

        # Top 5 usuarios m√°s activos
        top_users = db.query(User, UserHistory).join(UserHistory).order_by(
            UserHistory.recommendations_count.desc()
        ).limit(5).all()

        top_users_data = [
            {
                "email": user.email,
                "name": user.name,
                "recommendations": history.recommendations_count,
                "joined": user.created_at.strftime('%d/%m/%Y')
            }
            for user, history in top_users
        ]

        return {
            "success": True,
            "stats": {
                "total_users": total_users,
                "today_users": today_users,
                "week_users": week_users,
                "active_users": active_users,
                "total_recommendations": total_recommendations,
                "avg_recommendations_per_user": round(total_recommendations / max(total_users, 1), 2),
                # Nuevas estad√≠sticas de feedback
                "total_feedback": total_feedback,
                "accepted_feedback": accepted_feedback,
                "rejected_feedback": rejected_feedback,
                "acceptance_rate": round(accepted_feedback / max(total_feedback, 1) * 100, 1)
            },
            "top_users": top_users_data,
            "generated_at": datetime.utcnow().strftime('%d/%m/%Y %H:%M')
        }

    except Exception as e:
        raise HTTPException(500, f"Error obteniendo estad√≠sticas: {str(e)}")

@app.get("/admin/feedback-stats")
async def get_feedback_stats(db: Session = Depends(get_db)):
    """Estad√≠sticas detalladas de feedback para an√°lisis"""

    try:
        # Total feedback recibido
        total_feedback = db.query(UserFeedback).count()

        # Aceptados vs rechazados
        accepted_count = db.query(UserFeedback).filter(UserFeedback.accepted == 'si').count()
        rejected_count = db.query(UserFeedback).filter(UserFeedback.accepted == 'no').count()

        # Razones m√°s comunes de rechazo
        rejection_data = db.query(UserFeedback.rejection_reason).filter(
            UserFeedback.rejection_reason.isnot(None)
        ).all()

        # Contar razones
        reason_counts = {}
        for (reason,) in rejection_data:
            if reason:  # Verificar que no sea None
                reason_counts[reason] = reason_counts.get(reason, 0) + 1

        # Top 5 razones de rechazo
        top_rejection_reasons = sorted(reason_counts.items(), key=lambda x: x[1], reverse=True)[:5]

        # Feedback por combinaci√≥n
        combination_stats = db.query(
            UserFeedback.combination_id,
            UserFeedback.accepted,
            db.func.count(UserFeedback.id).label('count')
        ).group_by(UserFeedback.combination_id, UserFeedback.accepted).all()

        # Procesar estad√≠sticas por combinaci√≥n
        combination_data = {}
        for combo_id, accepted, count in combination_stats:
            if combo_id not in combination_data:
                combination_data[combo_id] = {'accepted': 0, 'rejected': 0}
            if accepted == 'si':
                combination_data[combo_id]['accepted'] = count
            else:
                combination_data[combo_id]['rejected'] = count

        return {
            "success": True,
            "stats": {
                "total_feedback": total_feedback,
                "accepted_count": accepted_count,
                "rejected_count": rejected_count,
                "acceptance_rate": round(accepted_count / max(total_feedback, 1) * 100, 2),
                "top_rejection_reasons": top_rejection_reasons,
                "combination_performance": combination_data
            },
            "generated_at": datetime.utcnow().strftime('%d/%m/%Y %H:%M')
        }

    except Exception as e:
        raise HTTPException(500, f"Error obteniendo estad√≠sticas de feedback: {str(e)}")

@app.get("/admin/users")
async def get_all_users(
    page: int = 1,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """
    Lista todos los usuarios con paginaci√≥n
    """
    try:
        # Offset para paginaci√≥n
        offset = (page - 1) * limit

        # Obtener usuarios con su historial
        users_with_history = db.query(User, UserHistory).join(UserHistory).offset(offset).limit(limit).all()

        users_data = []
        for user, history in users_with_history:
            days_passed = (datetime.utcnow() - history.start_date).days
            days_remaining = max(0, 30 - days_passed)

            # Obtener estad√≠sticas de feedback del usuario
            user_feedback_count = db.query(UserFeedback).filter(UserFeedback.user_id == user.id).count()
            user_accepted = db.query(UserFeedback).filter(
                UserFeedback.user_id == user.id,
                UserFeedback.accepted == 'si'
            ).count()

            users_data.append({
                "id": user.id,
                "email": user.email,
                "name": user.name or "Sin nombre",
                "joined": user.created_at.strftime('%d/%m/%Y %H:%M'),
                "recommendations_count": history.recommendations_count,
                "plan_type": history.plan_type,
                "days_remaining": days_remaining,
                "is_active": user.is_active,
                "feedback_given": user_feedback_count,
                "acceptance_rate": round(user_accepted / max(user_feedback_count, 1) * 100, 1)
            })

        # Total de usuarios para paginaci√≥n
        total_users = db.query(User).count()
        total_pages = (total_users + limit - 1) // limit

        return {
            "success": True,
            "users": users_data,
            "pagination": {
                "page": page,
                "limit": limit,
                "total_users": total_users,
                "total_pages": total_pages,
                "has_next": page < total_pages,
                "has_prev": page > 1
            }
        }

    except Exception as e:
        raise HTTPException(500, f"Error obteniendo usuarios: {str(e)}")

@app.get("/admin/user/{email}/details")
async def get_user_details(email: str, db: Session = Depends(get_db)):
    """
    Detalles completos de un usuario espec√≠fico
    """
    try:
        user = db.query(User).filter(User.email == email).first()
        if not user:
            raise HTTPException(404, "Usuario no encontrado")

        history = db.query(UserHistory).filter(UserHistory.user_id == user.id).first()

        # Parsear historial de outfits
        outfits_created = json.loads(history.outfits_created) if history and history.outfits_created else []

        days_passed = (datetime.utcnow() - history.start_date).days if history else 0
        days_remaining = max(0, 30 - days_passed) if history else 30

        # üéØ OBTENER FEEDBACK DEL USUARIO
        user_feedback = db.query(UserFeedback).filter(UserFeedback.user_id == user.id).all()

        feedback_data = []
        for feedback in user_feedback[-10:]:  # √öltimos 10 feedbacks
            feedback_data.append({
                "combination_id": feedback.combination_id,
                "accepted": feedback.accepted,
                "rejection_reason": feedback.rejection_reason,
                "date": feedback.created_at.strftime('%d/%m/%Y %H:%M')
            })

        feedback_stats = {
            "total": len(user_feedback),
            "accepted": len([f for f in user_feedback if f.accepted == 'si']),
            "rejected": len([f for f in user_feedback if f.accepted == 'no'])
        }

        return {
            "success": True,
            "user": {
                "id": user.id,
                "email": user.email,
                "name": user.name,
                "google_id": user.google_id,
                "created_at": user.created_at.strftime('%d/%m/%Y %H:%M'),
                "is_active": user.is_active
            },
            "history": {
                "plan_type": history.plan_type if history else "B√°sico",
                "start_date": history.start_date.strftime('%d/%m/%Y') if history else "N/A",
                "recommendations_count": history.recommendations_count if history else 0,
                "days_remaining": days_remaining,
                "outfits_created": outfits_created,
                "last_activity": outfits_created[-1]['date'] if outfits_created else "Sin actividad"
            },
            "feedback": {
                "stats": feedback_stats,
                "recent_feedback": feedback_data
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(500, f"Error obteniendo detalles del usuario: {str(e)}")

@app.delete("/admin/user/{email}")
async def delete_user(email: str, db: Session = Depends(get_db)):
    """
    Eliminar un usuario (solo para casos necesarios)
    """
    try:
        user = db.query(User).filter(User.email == email).first()
        if not user:
            raise HTTPException(404, "Usuario no encontrado")

        # Eliminar feedback del usuario primero
        db.query(UserFeedback).filter(UserFeedback.user_id == user.id).delete()

        # Eliminar historial
        db.query(UserHistory).filter(UserHistory.user_id == user.id).delete()

        # Eliminar usuario
        db.delete(user)
        db.commit()

        return {
            "success": True,
            "message": f"Usuario {email} eliminado exitosamente"
        }

    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(500, f"Error eliminando usuario: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", "8000"))  # Default 8000, configurable
    uvicorn.run("main:app", host="0.0.0.0", port=port)
