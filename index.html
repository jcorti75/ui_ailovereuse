# backend/main.py
import os, hashlib, io, time
from typing import List
from contextlib import asynccontextmanager
from fastapi import FastAPI, File, UploadFile, HTTPException, Request, Form
from fastapi.middleware.cors import CORSMiddleware
from PIL import Image
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sentence_transformers import SentenceTransformer

# ⬇️ IMPORTS PARA SISTEMA DE USUARIOS Y FEEDBACK:
from dotenv import load_dotenv
from datetime import datetime, timedelta
import json
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Text, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session, relationship
from fastapi import Depends
from pydantic import BaseModel

# ⬇️ CARGAR VARIABLES DEL .env:
load_dotenv()

# ---------- Config ----------
_model = None

def get_model():
    """Cargar modelo solo cuando sea necesario"""
    global _model
    if _model is None:
        print("Cargando modelo...")
        _model = SentenceTransformer("clip-ViT-B-32")  # Modelo más liviano
        print("Modelo cargado exitosamente")
    return _model

ALLOWED = {"image/jpeg", "image/png", "image/jpg", "image/webp", "image/gif",
           "image/svg+xml", "image/tiff", "image/bmp", "image/x-icon", "image/heic", "image/heif"}

# Aumentar límite a 20MB
MAX_MB = 20

# CORS configurable por ENV (coma-separado) o default a tu dominio
_env_origins = os.getenv(
    "ALLOWED_ORIGINS",
    "https://www.ailovereuse.com,https://ailovereuse.com,http://localhost:3000,http://localhost:5173,http://localhost:8080"
)
ALLOWED_ORIGINS = [o.strip() for o in _env_origins.split(",") if o.strip()]

# ---------- Database Config ----------
DATABASE_URL = "sqlite:///./ailovereuse.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ---------- Database Models ----------
class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    name = Column(String, nullable=True)  # Nombre de Google
    google_id = Column(String, nullable=True)  # ID de Google
    created_at = Column(DateTime, default=datetime.utcnow)
    is_active = Column(Integer, default=1)

    # Relaciones
    history = relationship("UserHistory", back_populates="user")
    feedback = relationship("UserFeedback", back_populates="user")  # Nueva relación

class UserHistory(Base):
    __tablename__ = "user_history"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    plan_type = Column(String, default="Básico")
    start_date = Column(DateTime, default=datetime.utcnow)
    recommendations_count = Column(Integer, default=0)
    outfits_created = Column(Text, default="[]")  # JSON string

    # Relación con usuario
    user = relationship("User", back_populates="history")

class UserFeedback(Base):
    """Tabla para almacenar feedback de combinaciones"""
    __tablename__ = "user_feedback"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    combination_id = Column(String, nullable=False)  # A1, B1, C1, etc.
    accepted = Column(String, nullable=False)  # 'si' o 'no'
    rejection_reason = Column(String, nullable=True)  # Solo si accepted = 'no'
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relación con usuario
    user = relationship("User", back_populates="feedback")

# Crear tablas
Base.metadata.create_all(bind=engine)

# ---------- Database Dependencies ----------
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------- User Helper Functions ----------
def get_or_create_user_by_email(db: Session, email: str, name: str = None) -> User:
    """Obtener usuario existente o crear uno nuevo por email"""
    user = db.query(User).filter(User.email == email).first()

    if not user:
        # Auto-crear usuario nuevo
        user = User(
            email=email,
            name=name,
            created_at=datetime.utcnow()
        )
        db.add(user)
        db.commit()
        db.refresh(user)

        # Crear historial inicial
        history = UserHistory(user_id=user.id)
        db.add(history)
        db.commit()

        print(f"✅ Usuario auto-creado: {email}")

    return user

def update_user_stats(db: Session, user_id: int, action_type: str):
    """Actualizar estadísticas del usuario"""
    history = db.query(UserHistory).filter(UserHistory.user_id == user_id).first()
    if not history:
        # Crear historial si no existe
        history = UserHistory(user_id=user_id)
        db.add(history)

    if action_type == 'recommendation':
        history.recommendations_count += 1
    elif action_type == 'outfit_created':
        outfits = json.loads(history.outfits_created)
        outfits.append({
            'date': datetime.utcnow().isoformat(),
            'type': 'outfit_generated'
        })
        history.outfits_created = json.dumps(outfits)

    db.commit()

# ---------- Cache y Lifespan ----------
_cache: dict[str, np.ndarray] = {}

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("🚀 Iniciando ailovereuse...")
    print("🤖 Pre-calentando IA...")

    # Cargar modelo al startup
    model = get_model()

    # Hacer inferencia dummy para cargar todo en memoria
    model.encode("warmup text")

    print("✅ IA lista - ailovereuse preparado para usuarios!")
    print("🔐 Autenticación: Google Login integrado")
    print("📊 Base de datos: ailovereuse.db")
    print("💬 Sistema de feedback: Activado")
    print("API iniciada")

    yield

    print("API cerrada")

# ---------- App ----------
if os.getenv("ENVIRONMENT") == "development":
    ALLOWED_ORIGINS = ["*"]

print("🌐 CORS Origins permitidos:", ALLOWED_ORIGINS)

app = FastAPI(title="I Love Reuse AI - Outfit Recommender", lifespan=lifespan)
app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
)

# ---------- Utilidades ----------
def _hash(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

def _load_img(b: bytes) -> Image.Image:
    img = Image.open(io.BytesIO(b)).convert("RGB")
    try:
        # Aplicar orientación EXIF si la tiene
        from PIL import ImageOps
        img = ImageOps.exif_transpose(img)
    except Exception:
        pass
    return img

def _embed(img: Image.Image) -> np.ndarray:
    model = get_model()  # ← Cargar solo cuando se necesite
    e = model.encode([img], convert_to_numpy=True, normalize_embeddings=True)[0]
    return e

def classify_formality(img: Image.Image) -> str:
    labels = ["formal outfit", "informal outfit", "dress shoe", "sneaker"]
    model = get_model()  # ← Cargar solo cuando se necesite
    txt = model.encode(labels, convert_to_numpy=True, normalize_embeddings=True)
    v = _embed(img).reshape(1, -1)
    s = cosine_similarity(v, txt)[0]
    return "formal" if (s[0] + s[2]) >= (s[1] + s[3]) else "informal"

def combine(a: np.ndarray, b: np.ndarray) -> np.ndarray:
    v = (a + b) / 2.0
    return v / (np.linalg.norm(v) + 1e-9)

def resize_uploaded_image(image_bytes, size=(128, 128)):
    img = Image.open(io.BytesIO(image_bytes))
    img = img.resize(size, Image.Resampling.LANCZOS)
    buffer = io.BytesIO()
    img.save(buffer, format='PNG', optimize=True)
    buffer.seek(0)
    return buffer.getvalue()

# ---------- Zero-shot prompts para "¿es prenda?" ----------
CLOTHING_LABELS_EN = [
    "a photo of a piece of clothing", "a photo of clothing", "a photo of an outfit",
    "a photo of a shirt", "a photo of a blouse", "a photo of a t-shirt",
    "a photo of a sweater", "a photo of a hoodie", "a photo of pants", "a photo of jeans",
    "a photo of a skirt", "a photo of shorts", "a photo of a dress",
    "a photo of a jacket", "a photo of a coat", "a photo of a blazer", "a photo of a parka",
    "a photo of a pair of shoes", "a photo of sneakers", "a photo of boots",
    "a photo of heels", "a photo of loafers", "a photo of sandals",
    "a photo of a handbag", "a photo of a purse", "a photo of a backpack",
    "a photo of a belt", "a photo of a scarf", "a photo of sunglasses",
    "a photo of jewelry", "a photo of a wallet", "a photo of socks"
]

NON_CLOTHING_LABELS_EN = [
    "a photo of an animal", "a photo of a dog", "a photo of a cat",
    "a photo of a house", "a photo of a room", "a photo of a window",
    "a photo of a car", "a photo of a wheel", "a photo of a motorcycle",
    "a photo of furniture", "a photo of a chair", "a photo of a table",
    "a photo of food", "a photo of electronics", "a photo of a phone",
    "a photo of a landscape", "a photo of a city", "a photo of a person portrait"
]

_text_cache = {"clothing": None, "non_clothing": None}

def _get_text_embs():
    model = get_model()
    if _text_cache["clothing"] is None:
        _text_cache["clothing"] = model.encode(
            CLOTHING_LABELS_EN, convert_to_numpy=True, normalize_embeddings=True
        )
    if _text_cache["non_clothing"] is None:
        _text_cache["non_clothing"] = model.encode(
            NON_CLOTHING_LABELS_EN, convert_to_numpy=True, normalize_embeddings=True
        )
    return _text_cache["clothing"], _text_cache["non_clothing"]

def is_clothing_image(img: Image.Image, thr: float = 0.30, margin: float = 0.10):
    """
    Zero-shot con CLIP para decidir si una imagen es de prenda/accesorio/outfit.
    thr: similitud mínima con 'ropa' para aceptar.
    margin: 'ropa' debe superar a 'no-ropa' al menos por este margen.
    """
    model = get_model()
    clothing_embs, non_clothing_embs = _get_text_embs()

    img_emb = model.encode(img, convert_to_numpy=True, normalize_embeddings=True).reshape(1, -1)

    sim_clothing = cosine_similarity(img_emb, clothing_embs)[0]
    sim_non_clothing = cosine_similarity(img_emb, non_clothing_embs)[0]

    best_clothing = float(np.max(sim_clothing))
    best_non_clothing = float(np.max(sim_non_clothing))
    best_label = CLOTHING_LABELS_EN[int(np.argmax(sim_clothing))]

    ok = (best_clothing >= thr) and (best_clothing > best_non_clothing + margin)

    return ok, {
        "best_clothing_score": round(best_clothing, 3),
        "best_non_clothing_score": round(best_non_clothing, 3),
        "predicted_label": best_label if ok else "NOT_CLOTHING"
    }

# (Opcional) filtro específico para calzado
FOOTWEAR_LABELS_EN = [
    "a photo of a pair of shoes", "a photo of sneakers", "a photo of boots",
    "a photo of heels", "a photo of loafers", "a photo of sandals"
]
def is_footwear_image(img: Image.Image, thr: float = 0.30):
    model = get_model()
    footwear_embs = model.encode(FOOTWEAR_LABELS_EN, convert_to_numpy=True, normalize_embeddings=True)
    img_emb = model.encode(img, convert_to_numpy=True, normalize_embeddings=True).reshape(1, -1)
    sim = cosine_similarity(img_emb, footwear_embs)[0]
    return (float(np.max(sim)) >= thr)

# ---------- Main Endpoints ----------
@app.get("/")
def read_root():
    return {
        "message": "I Love Reuse AI - Outfit Recommender funcionando!",
        "version": "4.0",
        "auth": "Google Login integrado",
        "model": "lazy-loaded",
        "max_file_size": f"{MAX_MB}MB",
        "database": "SQLite - ailovereuse.db",
        "feedback_system": "Activo"
    }

@app.get("/health")
def health():
    return {
        "ok": True,
        "ts": int(time.time()),
        "model_loaded": _model is not None,
        "max_file_size": f"{MAX_MB}MB",
        "auth_system": "google_integrated",
        "database": "ailovereuse.db",
        "features": ["recommendations", "user_tracking", "feedback_system"]
    }

# ---------- User History Endpoint ----------
@app.get("/user/history/{email}")
async def get_user_history_by_email(email: str, db: Session = Depends(get_db)):
    """Obtener historial de usuario por email (para usuarios loggeados con Google)"""
    user = db.query(User).filter(User.email == email).first()

    if not user:
        # Si no existe, crear usuario automáticamente
        user = get_or_create_user_by_email(db, email)

    history = db.query(UserHistory).filter(UserHistory.user_id == user.id).first()

    if not history:
        # Crear historial si no existe
        history = UserHistory(user_id=user.id)
        db.add(history)
        db.commit()
        db.refresh(history)

    # Calcular días restantes
    days_passed = (datetime.utcnow() - history.start_date).days
    days_remaining = max(0, 30 - days_passed)

    # Obtener estadísticas de feedback
    total_feedback = db.query(UserFeedback).filter(UserFeedback.user_id == user.id).count()
    accepted_feedback = db.query(UserFeedback).filter(
        UserFeedback.user_id == user.id,
        UserFeedback.accepted == 'si'
    ).count()

    return {
        "success": True,
        "user": {
            "email": user.email,
            "name": user.name,
            "joined": user.created_at.strftime('%d/%m/%Y')
        },
        "data": {
            "start_date": history.start_date.strftime('%d/%m/%Y'),
            "plan_type": history.plan_type,
            "days_remaining": days_remaining,
            "recommendations_count": history.recommendations_count,
            "outfits_created": json.loads(history.outfits_created),
            "feedback_given": total_feedback,
            "acceptance_rate": round(accepted_feedback / max(total_feedback, 1) * 100, 1)
        }
    }

# ---------- Classification Endpoint ----------
@app.post("/classify")
async def classify(file: UploadFile = File(...)):
    # Verificar tipo de archivo (case-insensitive)
    if file.content_type.lower() not in ALLOWED:
        raise HTTPException(415, f"Tipo de archivo no permitido: {file.content_type}. Por favor sube una imagen válida (JPG, PNG, etc.)")

    b = await file.read()
    file_size_mb = len(b) / (1024 * 1024)  # Convertir a MB

    if len(b) > MAX_MB * 1024 * 1024:
        raise HTTPException(413, f"La imagen es muy grande ({file_size_mb:.1f}MB). Por favor sube una foto más pequeña (máximo {MAX_MB}MB)")

    try:
        img = _load_img(b)
    except Exception:
        raise HTTPException(400, "Archivo de imagen inválido. Por favor verifica que sea una imagen válida")

    # ✅ Validación de prenda/outfit antes de clasificar
    ok, info = is_clothing_image(img)
    if not ok:
        raise HTTPException(
            status_code=422,
            detail={
                "code": "NOT_CLOTHING",
                "message": "La imagen no corresponde a una prenda ni outfit.",
                "debug": info  # quita 'debug' en producción si no quieres exponer detalles
            }
        )

    return {"formality": classify_formality(img)}

# ---------- Recommendation Endpoint (CON GOOGLE AUTH INTEGRADO) ----------
@app.post("/recommend")
async def recommend(
    request: Request,
    top: UploadFile = File(...),
    bottom: UploadFile = File(...),
    shoes: List[UploadFile] = File(...),
    user_email: str = Form(...),  # 👈 Email del usuario loggeado con Google
    user_name: str = Form(None),  # 👈 Nombre opcional de Google
    db: Session = Depends(get_db)
):
    """
    Generar recomendación de outfit.

    Parámetros:
    - top: Imagen de parte superior
    - bottom: Imagen de parte inferior
    - shoes: Lista de imágenes de zapatos
    - user_email: Email del usuario (obtenido del login de Google)
    - user_name: Nombre del usuario (opcional, de Google)
    """

    # Validar email
    if not user_email or "@" not in user_email:
        raise HTTPException(400, "Email de usuario requerido y válido")

    # Obtener o crear usuario automáticamente
    user = get_or_create_user_by_email(db, user_email, user_name)

    # Validar y leer archivos
    files_all = [("top", top), ("bottom", bottom)] + [(f"shoe[{i}]", s) for i, s in enumerate(shoes)]
    buffers: dict[str, bytes] = {}

    for name, f in files_all:
        # Verificar tipo de archivo (case-insensitive)
        if f.content_type.lower() not in ALLOWED:
            raise HTTPException(415, f"Tipo de archivo no permitido en {name}: {f.content_type}. Por favor sube una imagen válida (JPG, PNG, etc.)")

        b = await f.read()
        if not b:
            raise HTTPException(400, f"El archivo {name} está vacío. Por favor selecciona una imagen válida")

        file_size_mb = len(b) / (1024 * 1024)  # Convertir a MB
        if len(b) > MAX_MB * 1024 * 1024:
            raise HTTPException(413, f"La imagen {name} es muy grande ({file_size_mb:.1f}MB). Por favor sube una foto más pequeña (máximo {MAX_MB}MB)")

        # ✅ Validación semántica: debe ser prenda/outfit/accesorio
        try:
            _img_tmp = _load_img(b)
        except Exception:
            raise HTTPException(400, f"El archivo {name} no es una imagen válida")

        ok, info = is_clothing_image(_img_tmp)
        if not ok:
            raise HTTPException(
                status_code=422,
                detail={
                    "code": "NOT_CLOTHING",
                    "field": name,  # ej: "top", "bottom", "shoe[0]"
                    "message": "La imagen no corresponde a una prenda, calzado, accesorio ni outfit.",
                    "debug": info
                }
            )

        # (Opcional) si quieres que 'shoes' solo acepte calzado:
        if name.startswith("shoe["):
            if not is_footwear_image(_img_tmp):
                raise HTTPException(
                    status_code=422,
                    detail={
                        "code": "NOT_FOOTWEAR",
                        "field": name,
                        "message": "La imagen en la sección de calzado no parece ser un zapato/zapatilla.",
                    }
                )

        buffers[name] = b

    def get_emb(b: bytes) -> np.ndarray:
        key = _hash(b)
        if key not in _cache:
            _cache[key] = _embed(_load_img(b))
        return _cache[key]

    e_top = get_emb(buffers["top"])
    e_bot = get_emb(buffers["bottom"])
    outfit = combine(e_top, e_bot).reshape(1, -1)

    shoe_keys = [k for k in buffers.keys() if k.startswith("shoe[")]
    if not shoe_keys:
        raise HTTPException(400, "Debes enviar al menos una imagen de zapatos")

    shoe_embs = [get_emb(buffers[k]).reshape(1, -1) for k in shoe_keys]
    sims = [float(cosine_similarity(outfit, e)[0][0]) for e in shoe_embs]
    order = np.argsort(-np.array(sims)).tolist()
    k = min(3, len(order))

    results = []
    for rank, i in enumerate(order[:k], start=1):
        key = shoe_keys[i]
        label = classify_formality(_load_img(buffers[key]))
        results.append({
            "index": i,
            "score": sims[i],
            "formality": label,
            "combination": rank
        })

    # 🎯 ACTUALIZAR ESTADÍSTICAS DEL USUARIO
    update_user_stats(db, user.id, 'recommendation')

    # Obtener contador actualizado
    history = db.query(UserHistory).filter(UserHistory.user_id == user.id).first()
    total_recommendations = history.recommendations_count if history else 1

    payload = {
        "best_index": results[0]["index"] if results else None,
        "results": results,
        "user": {
            "email": user.email,
            "recommendations_total": total_recommendations
        }
    }

    print(f"✅ Recomendación generada para {user.email} (Total: {total_recommendations})")
    return payload

# ---------- 🎯 Feedback Endpoint ----------
@app.post("/api/feedback")
async def store_user_feedback(
    user_email: str = Form(...),
    combination_id: str = Form(...),
    accepted: str = Form(...),  # 'si' o 'no'
    rejection_reason: str = Form(None),  # opcional
    db: Session = Depends(get_db)
):
    """Almacenar feedback del usuario sobre combinaciones"""

    # Validar email
    if not user_email or "@" not in user_email:
        raise HTTPException(400, "Email válido requerido")

    # Validar accepted
    if accepted not in ['si', 'no']:
        raise HTTPException(400, "accepted debe ser 'si' o 'no'")

    # Obtener usuario
    user = db.query(User).filter(User.email == user_email).first()
    if not user:
        raise HTTPException(404, "Usuario no encontrado")

    try:
        # Crear registro de feedback
        feedback = UserFeedback(
            user_id=user.id,
            combination_id=combination_id,
            accepted=accepted,
            rejection_reason=rejection_reason if accepted == 'no' else None
        )

        db.add(feedback)
        db.commit()
        db.refresh(feedback)

        print(f"✅ Feedback almacenado: {user.email} - {combination_id} - {accepted}")
        if rejection_reason:
            print(f"   Razón de rechazo: {rejection_reason}")

        return {
            "success": True,
            "message": "Feedback almacenado correctamente",
            "feedback_id": feedback.id
        }

    except Exception as e:
        db.rollback()
        raise HTTPException(500, f"Error almacenando feedback: {str(e)}")

# ---------- Admin Endpoints ----------
@app.get("/admin/stats")
async def get_admin_stats(db: Session = Depends(get_db)):
    """
    Estadísticas generales de la aplicación para el administrador
    """
    try:
        # Contar usuarios totales
        total_users = db.query(User).count()

        # Usuarios de hoy
        today = datetime.utcnow().date()
        today_users = db.query(User).filter(
            User.created_at >= datetime.combine(today, datetime.min.time())
        ).count()

        # Usuarios de esta semana
        week_ago = datetime.utcnow() - timedelta(days=7)
        week_users = db.query(User).filter(User.created_at >= week_ago).count()

        # Usuarios activos (con recomendaciones)
        active_users = db.query(UserHistory).filter(
            UserHistory.recommendations_count > 0
        ).count()

        # Total de recomendaciones generadas
        total_recommendations = db.query(UserHistory).with_entities(
            db.func.sum(UserHistory.recommendations_count)
        ).scalar() or 0

        # 🎯 NUEVAS ESTADÍSTICAS DE FEEDBACK
        total_feedback = db.query(UserFeedback).count()
        accepted_feedback = db.query(UserFeedback).filter(UserFeedback.accepted == 'si').count()
        rejected_feedback = db.query(UserFeedback).filter(UserFeedback.accepted == 'no').count()

        # Top 5 usuarios más activos
        top_users = db.query(User, UserHistory).join(UserHistory).order_by(
            UserHistory.recommendations_count.desc()
        ).limit(5).all()

        top_users_data = [
            {
                "email": user.email,
                "name": user.name,
                "recommendations": history.recommendations_count,
                "joined": user.created_at.strftime('%d/%m/%Y')
            }
            for user, history in top_users
        ]

        return {
            "success": True,
            "stats": {
                "total_users": total_users,
                "today_users": today_users,
                "week_users": week_users,
                "active_users": active_users,
                "total_recommendations": total_recommendations,
                "avg_recommendations_per_user": round(total_recommendations / max(total_users, 1), 2),
                # Nuevas estadísticas de feedback
                "total_feedback": total_feedback,
                "accepted_feedback": accepted_feedback,
                "rejected_feedback": rejected_feedback,
                "acceptance_rate": round(accepted_feedback / max(total_feedback, 1) * 100, 1)
            },
            "top_users": top_users_data,
            "generated_at": datetime.utcnow().strftime('%d/%m/%Y %H:%M')
        }

    except Exception as e:
        raise HTTPException(500, f"Error obteniendo estadísticas: {str(e)}")

@app.get("/admin/feedback-stats")
async def get_feedback_stats(db: Session = Depends(get_db)):
    """Estadísticas detalladas de feedback para análisis"""

    try:
        # Total feedback recibido
        total_feedback = db.query(UserFeedback).count()

        # Aceptados vs rechazados
        accepted_count = db.query(UserFeedback).filter(UserFeedback.accepted == 'si').count()
        rejected_count = db.query(UserFeedback).filter(UserFeedback.accepted == 'no').count()

        # Razones más comunes de rechazo
        rejection_data = db.query(UserFeedback.rejection_reason).filter(
            UserFeedback.rejection_reason.isnot(None)
        ).all()

        # Contar razones
        reason_counts = {}
        for (reason,) in rejection_data:
            if reason:  # Verificar que no sea None
                reason_counts[reason] = reason_counts.get(reason, 0) + 1

        # Top 5 razones de rechazo
        top_rejection_reasons = sorted(reason_counts.items(), key=lambda x: x[1], reverse=True)[:5]

        # Feedback por combinación
        combination_stats = db.query(
            UserFeedback.combination_id,
            UserFeedback.accepted,
            db.func.count(UserFeedback.id).label('count')
        ).group_by(UserFeedback.combination_id, UserFeedback.accepted).all()

        # Procesar estadísticas por combinación
        combination_data = {}
        for combo_id, accepted, count in combination_stats:
            if combo_id not in combination_data:
                combination_data[combo_id] = {'accepted': 0, 'rejected': 0}
            if accepted == 'si':
                combination_data[combo_id]['accepted'] = count
            else:
                combination_data[combo_id]['rejected'] = count

        return {
            "success": True,
            "stats": {
                "total_feedback": total_feedback,
                "accepted_count": accepted_count,
                "rejected_count": rejected_count,
                "acceptance_rate": round(accepted_count / max(total_feedback, 1) * 100, 2),
                "top_rejection_reasons": top_rejection_reasons,
                "combination_performance": combination_data
            },
            "generated_at": datetime.utcnow().strftime('%d/%m/%Y %H:%M')
        }

    except Exception as e:
        raise HTTPException(500, f"Error obteniendo estadísticas de feedback: {str(e)}")

@app.get("/admin/users")
async def get_all_users(
    page: int = 1,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """
    Lista todos los usuarios con paginación
    """
    try:
        # Offset para paginación
        offset = (page - 1) * limit

        # Obtener usuarios con su historial
        users_with_history = db.query(User, UserHistory).join(UserHistory).offset(offset).limit(limit).all()

        users_data = []
        for user, history in users_with_history:
            days_passed = (datetime.utcnow() - history.start_date).days
            days_remaining = max(0, 30 - days_passed)

            # Obtener estadísticas de feedback del usuario
            user_feedback_count = db.query(UserFeedback).filter(UserFeedback.user_id == user.id).count()
            user_accepted = db.query(UserFeedback).filter(
                UserFeedback.user_id == user.id,
                UserFeedback.accepted == 'si'
            ).count()

            users_data.append({
                "id": user.id,
                "email": user.email,
                "name": user.name or "Sin nombre",
                "joined": user.created_at.strftime('%d/%m/%Y %H:%M'),
                "recommendations_count": history.recommendations_count,
                "plan_type": history.plan_type,
                "days_remaining": days_remaining,
                "is_active": user.is_active,
                "feedback_given": user_feedback_count,
                "acceptance_rate": round(user_accepted / max(user_feedback_count, 1) * 100, 1)
            })

        # Total de usuarios para paginación
        total_users = db.query(User).count()
        total_pages = (total_users + limit - 1) // limit

        return {
            "success": True,
            "users": users_data,
            "pagination": {
                "page": page,
                "limit": limit,
                "total_users": total_users,
                "total_pages": total_pages,
                "has_next": page < total_pages,
                "has_prev": page > 1
            }
        }

    except Exception as e:
        raise HTTPException(500, f"Error obteniendo usuarios: {str(e)}")

@app.get("/admin/user/{email}/details")
async def get_user_details(email: str, db: Session = Depends(get_db)):
    """
    Detalles completos de un usuario específico
    """
    try:
        user = db.query(User).filter(User.email == email).first()
        if not user:
            raise HTTPException(404, "Usuario no encontrado")

        history = db.query(UserHistory).filter(UserHistory.user_id == user.id).first()

        # Parsear historial de outfits
        outfits_created = json.loads(history.outfits_created) if history and history.outfits_created else []

        days_passed = (datetime.utcnow() - history.start_date).days if history else 0
        days_remaining = max(0, 30 - days_passed) if history else 30

        # 🎯 OBTENER FEEDBACK DEL USUARIO
        user_feedback = db.query(UserFeedback).filter(UserFeedback.user_id == user.id).all()

        feedback_data = []
        for feedback in user_feedback[-10:]:  # Últimos 10 feedbacks
            feedback_data.append({
                "combination_id": feedback.combination_id,
                "accepted": feedback.accepted,
                "rejection_reason": feedback.rejection_reason,
                "date": feedback.created_at.strftime('%d/%m/%Y %H:%M')
            })

        feedback_stats = {
            "total": len(user_feedback),
            "accepted": len([f for f in user_feedback if f.accepted == 'si']),
            "rejected": len([f for f in user_feedback if f.accepted == 'no'])
        }

        return {
            "success": True,
            "user": {
                "id": user.id,
                "email": user.email,
                "name": user.name,
                "google_id": user.google_id,
                "created_at": user.created_at.strftime('%d/%m/%Y %H:%M'),
                "is_active": user.is_active
            },
            "history": {
                "plan_type": history.plan_type if history else "Básico",
                "start_date": history.start_date.strftime('%d/%m/%Y') if history else "N/A",
                "recommendations_count": history.recommendations_count if history else 0,
                "days_remaining": days_remaining,
                "outfits_created": outfits_created,
                "last_activity": outfits_created[-1]['date'] if outfits_created else "Sin actividad"
            },
            "feedback": {
                "stats": feedback_stats,
                "recent_feedback": feedback_data
            }
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(500, f"Error obteniendo detalles del usuario: {str(e)}")

@app.delete("/admin/user/{email}")
async def delete_user(email: str, db: Session = Depends(get_db)):
    """
    Eliminar un usuario (solo para casos necesarios)
    """
    try:
        user = db.query(User).filter(User.email == email).first()
        if not user:
            raise HTTPException(404, "Usuario no encontrado")

        # Eliminar feedback del usuario primero
        db.query(UserFeedback).filter(UserFeedback.user_id == user.id).delete()

        # Eliminar historial
        db.query(UserHistory).filter(UserHistory.user_id == user.id).delete()

        # Eliminar usuario
        db.delete(user)
        db.commit()

        return {
            "success": True,
            "message": f"Usuario {email} eliminado exitosamente"
        }

    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        raise HTTPException(500, f"Error eliminando usuario: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", "8000"))  # Default 8000, configurable
    uvicorn.run("main:app", host="0.0.0.0", port=port)
